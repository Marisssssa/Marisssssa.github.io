---

layout: post
title:  "C++12.c++中的内存相关问题"
date:   2022-08-16
excerpt: "cpp."
tag:
- C++
- 内存
comments: false
---

<center><b>C++12.c++中的内存相关问题.</b> </center>

# C++12.c++中的内存相关问题

#### c++中的内存分区

![image-20220819160857475](https://raw.githubusercontent.com/Marisssssa/ImageBed/main/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png)

栈：由**编译器管理**分配和回收。存放局部变量和函数参数。栈内存分配运算内置于处理器的指令集中，**效率高**，但是分配的内存**容量有限**。

堆：由**程序员管理**，需要⼿动 new malloc delete free 进⾏分配和回收。**空间较⼤**，但可能会出现**内存泄漏和空闲碎⽚**的情况。

全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化。

常量存储区：存储常量，⼀般不允许修改。

代码区：存放程序的⼆进制代码。



#### 内存分配和管理

| 函数    | 作用                                                         |
| ------- | ------------------------------------------------------------ |
| malloc  | 申请指定字节数的内存。申请到的内存中的初始值不确定。         |
| calloc  | 为指定长度的对象分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。 |
| realloc | 更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的**内容移动**到另一个足够大的区域，而新增区域内的初始值则不确定。 |
| alloca  | 在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。 |



#### 内存泄漏相关问题

内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制。

⼀般**表现⽅式**是程序运⾏时间越⻓，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。

##### 内存泄漏位置定位

定位内存位置和大小：

在main函数最后面一行，加上一句**_CrtDumpMemoryLeaks()**。调试程序，自然关闭程序让其退出，查看输出：

```
{453}normal block at 0x02432CA8,868 bytes long
```

453是我们需要的内存泄漏定位值，868 bytes long指有868比特内存没有释放。

定位代码位置：

在main函数第一行加上**_CrtSetBreakAlloc(453)**;在申请453这块内存的位置中断。然后调试程序，程序中断了，查看调用堆栈。

##### 检测是否有内存泄漏

1.⾸先可以通过观察猜测是否可能发⽣内存泄漏，Linux 中使⽤ swap 命令观察还有多少可⽤的交换空间，在⼀两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。 

2.使⽤/usr/bin/stat ⼯具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，⼀个 可能的解释就是有个进程出现了内存泄漏。 

3.软件开发⼯具 valgrind 可进⾏内存泄漏的检测。



END