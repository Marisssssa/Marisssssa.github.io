---

layout: post
title:  "C++18.c++编译过程"
date:   2022-08-16
excerpt: "cpp.c++编译过程"
tag:
- C++
- 编译过程
- gcc
comments: false
---

<center><b>C++18.c++编译过程</b> </center>

# C++18.c++编译过程

1.预处理阶段

```
gcc -E myfile.cpp -o myfile.i//-E 预处理指定源文件，不进行编译
```

`Linux` 系统中，通常用 `.i` 或者 `.ii` 作为 `C/C++` 程序预处理后所得文件的后缀名。由此，就完成了 `myfile.cpp` 文件的预处理操作，并将其结果导入到了 `myfile.ii` 文件中。可以通过执行 `cat test.ii`指令查看该文件中的内容。

在该阶段，会将`x.h`文件（头文件）中的宏定义、引用和文件中的符号定义替换为真正的内容。预处理之后得到的仍然是文本文件，但文件体积会大很多。这是因为预处理中做了一些符号替换操作。



2.编译阶段

```
gcc -S myfile.i(或者myfile.cpp) -o myfile.s//-S 进行到编译过程（大写S）
```

所谓编译，简单理解就是将预处理得到的程序代码，经过一系列的词法分析、语法分析、语义分析以及优化，加工为当前机器支持的汇编代码。该步会检查语法，通常编程报错就是在该阶段。



3.汇编阶段

```
gcc -c myfile.i/s -o myfile.o//-c进行到汇编过程（小写c）
```

**汇编过程将上一步的汇编代码转换成机器码**。其本质为二进制文件，但由于尚未经过链接操作，所以无法直接运行。



4.链接阶段

```
gcc myfile.o -o myfile
```

完成链接操作，并不需要给 `g++` 添加任何选项，只要将汇编阶段得到的 `test.o` 作为参数传递给它，`g++`就会在其基础上完成链接操作。

gcc命令本身会生成`a.out`,与此步骤生成的myfile文件是完全相同的。

链接方式

a.静态链接

在链接阶段，**将汇编生成的.o文件和所需要的库一起链接打包到可执行文件中去**，程序运行的时候不再调用其它的库文件

一个静态库，可以看作是一些目标代码的集合，在可执行程序运行前就已经加入到执行代码中，成为执行程序的一部分。

静态链接的优点：对运行环境依赖小，具有较好的兼容性。

静态链接的缺点：生成的程序较大，需要更多的系统资源，在装入内存中消耗更多时间；一旦库函数有了更新，必须重新编译应用程序。

存在问题：若两个.o文件都使用同一个静态库，那么内存中会**拷贝2份静态库的代码**，然后分别与两个.o文件一起打包到可执行文件中，造成空间浪费；所需的库被拷贝到可执行文件中去了，如果**某个库更新**了，则与它相关的**所有可执行文件都需要重新编译**。

b.动态链接

动态库在程序编译时，并不会被链接到目标代码中，而是在**运行时载入**，不同应用程序如果调用相同的的库，内存里只有一份**共享库**的实例，避免了浪费。由于动态库在运行时才被载入，也解决了静态库对程序的更新、部署和发布带来的麻烦，用户只需要更新动态库即可。

动态链接的优点：链接时，仅仅建立与所需库函数之间的关系；在程序运行时才将所需资源调入可执行程序；简化程序的升级，有较小的程序体积；实现进程之间的资源共享，内存中只有一份动态库的实例，避免充分拷贝。

动态链接的缺点：**依赖动态库，不能独立运行；动态库依赖版本问题严重。**





END