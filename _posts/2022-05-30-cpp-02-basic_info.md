---
layout: post
title:  "C++02.基础修饰符"
date:   2022-05-30
excerpt: "cpp.基础修饰符"
tag:
- C++
- 基础修饰符
- this
- inline
- sizeof
comments: false
---

<center><b>02.基础修饰符.</b> </center>

# C++02.基础修饰符

## 一.this指针

### 1.this指针的注意点

- 一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。

- this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它**作为非静态成员函数的隐含形参，对各成员的访问均通过this进行**。

- 在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this。

- 当参数与成员变量名相同时，如this->n = n （不能写成n = n)。

### 2.this的编译问题

- 在编译的过程，this会被编译器解析成A *const的格式。（即常量指针，而不是指向常量的指针）

- this在成员函数的开始执行前构造，在成员的执行结束后清除。

## 二.inline内联

### 1.编译器对inline函数的处理步骤

 * 将 inline 函数体复制到 inline 函数调用点处；
 * 为所用 inline 函数中的局部变量分配内存空间；
 * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
 * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

### 2.何时用/不用内联函数

内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。

如果执行函数体内代码的时间相比于函数调用的开销较大，那么效率的收货会更少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。

以下情况**不宜用**内联：

> 如果函数体内的代码比较长，使得内联将导致内存消耗代价比较高。
>
> 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。

### 3.inline函数与虚函数

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是**当虚函数表现多态性的时候不能内联**。
- 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
- `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

### 三.sizeof()总结

> 空类的大小为1字节

> 一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间。

> 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针vptr的大小。

> 普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小

> 虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)

> 虚继承,继承基类的vptr。





END